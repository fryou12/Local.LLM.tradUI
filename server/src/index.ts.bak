import express from 'express';
import multer from 'multer';
import cors from 'cors';
import { join, dirname, basename, extname } from 'path';
import { mkdir, unlink, readFile, writeFile } from 'fs/promises';
import { statSync, existsSync } from 'fs';
import { randomBytes } from 'crypto';
import { tmpdir } from 'os';
import { debugLog } from './utils/logger';
import axios from 'axios';
import EventEmitter from 'events';
import pdf from 'pdf-parse';

// Configuration
const app = express();
const port = 3001;
const UPLOAD_DIR = join(__dirname, '../uploads');
const eventEmitter = new EventEmitter();

// Configuration CORS plus permissive
app.use((_req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

// Middleware
app.use(express.json());

// Créer le dossier uploads s'il n'existe pas
if (!existsSync(UPLOAD_DIR)) {
  mkdir(UPLOAD_DIR, { recursive: true });
}

// Configuration de Multer pour la gestion des fichiers
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, UPLOAD_DIR);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1E9)}`;
    cb(null, `${file.fieldname}-${uniqueSuffix}${extname(file.originalname)}`);
  }
});

const upload = multer({ storage: storage });

// Types
interface TranslationProgress {
  progress: number;
  status: 'extracting' | 'translating' | 'saving' | 'completed' | 'error';
  currentChunk?: number;
  totalChunks?: number;
  message?: string;
  estimatedTimeRemaining?: number;
}

interface TextChunk {
  text: string;
  pageNumber: number;
  chunkNumber: number;
}

interface OllamaModel {
  name: string;
  model: string;
  modified_at: string;
  size: number;
  digest: string;
  details: {
    parent_model: string;
    format: string;
    family: string;
    families: string[];
    parameter_size: string;
    quantization_level: string;
  };
}

interface OllamaResponse {
  models: OllamaModel[];
}

// Route pour récupérer la progression de la traduction
app.get('/api/translation-progress/:fileId', (_req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const progressListener = (data: TranslationProgress) => {
    const progress = {
      status: data.status,
      progress: data.progress,
      message: `Traduction en cours : ${data.currentChunk}/${data.totalChunks} chunks`,
      estimatedTimeRemaining: data.estimatedTimeRemaining
    };
    res.write(`data: ${JSON.stringify(progress)}\n\n`);
  };

  eventEmitter.on('translationProgress', progressListener);

  _req.on('close', () => {
    eventEmitter.removeListener('translationProgress', progressListener);
  });
});

// Fonction pour extraire le texte d'un fichier
async function extractTextFromFile(filePath: string, isOCRMode: boolean, ocrModel: string): Promise<TextChunk[]> {
  const chunks: TextChunk[] = [];
  const extension = extname(filePath).toLowerCase();

  if (extension === '.pdf') {
    if (isOCRMode) {
      debugLog('=== UTILISATION DE L\'OCR AVEC OLLAMA ===');
      debugLog('Modèle OCR:', ocrModel);

      // Lire le fichier PDF
      const pdfBuffer = await readFile(filePath);
      
      // Convertir le PDF en base64
      const base64PDF = pdfBuffer.toString('base64');
      
      // Préparer le prompt pour l'OCR
      const prompt = `You are an OCR system. Your task is to extract ONLY the main body text from this PDF document.

IMPORTANT INSTRUCTIONS:
- Extract ONLY the actual content text
- DO NOT describe images, figures, or diagrams
- DO NOT describe the document layout
- DO NOT include headers, footers, or page numbers
- DO NOT include cover information or metadata
- DO NOT add any commentary or descriptions
- Output the raw text content EXACTLY as it appears, preserving paragraphs
- Maintain the exact same writing style and formatting
- If you see mathematical formulas, extract them exactly as they appear

<image>
${base64PDF}
</image>

Output the extracted text now:`;

      // Faire la requête OCR à Ollama
      debugLog('Envoi de la requête OCR à Ollama...');
      const extractedText = await ollamaRequest(ocrModel, prompt);
      debugLog('Texte extrait par OCR');

      // Diviser le texte en chunks d'environ 1000 caractères
      const chunkSize = 1000;
      const words = extractedText.split(/\s+/);
      let currentChunk = '';
      let chunkNumber = 1;
      
      for (let i = 0; i < words.length; i++) {
        currentChunk += words[i] + ' ';
        
        if (currentChunk.length >= chunkSize || i === words.length - 1) {
          chunks.push({
            text: currentChunk.trim(),
            pageNumber: 1, // Pour l'instant, on ne gère pas les numéros de page avec l'OCR
            chunkNumber: chunkNumber++
          });
          currentChunk = '';
        }
      }
    } else {
      // Extraction de texte standard pour les PDF
      const pdfBuffer = await readFile(filePath);
      const data = await pdf(pdfBuffer);
      const text = data.text;
      
      // Diviser le texte en chunks d'environ 1000 caractères
      const chunkSize = 1000;
      const words = text.split(/\s+/);
      let currentChunk = '';
      let chunkNumber = 1;
      
      for (let i = 0; i < words.length; i++) {
        currentChunk += words[i] + ' ';
        
        if (currentChunk.length >= chunkSize || i === words.length - 1) {
          chunks.push({
            text: currentChunk.trim(),
            pageNumber: 1,
            chunkNumber: chunkNumber++
          });
          currentChunk = '';
        }
      }
    }
  } else if (extension === '.txt') {
    const text = await readFile(filePath, 'utf-8');
    
    // Diviser le texte en chunks d'environ 1000 caractères
    const chunkSize = 1000;
    const words = text.split(/\s+/);
    let currentChunk = '';
    let chunkNumber = 1;
    
    for (let i = 0; i < words.length; i++) {
      currentChunk += words[i] + ' ';
      
      if (currentChunk.length >= chunkSize || i === words.length - 1) {
        chunks.push({
          text: currentChunk.trim(),
          pageNumber: 1,
          chunkNumber: chunkNumber++
        });
        currentChunk = '';
      }
    }
  } else {
    throw new Error(`Format de fichier non supporté: ${extension}`);
  }

  return chunks;
}

// Fonction pour faire une requête à Ollama
async function ollamaRequest(model: string, prompt: string): Promise<string> {
  debugLog('=== DÉBUT REQUÊTE OLLAMA ===');
  debugLog('Modèle:', model);
  debugLog('Longueur du prompt:', prompt.length);

  try {
    const response = await axios.post('http://localhost:11434/api/generate', {
      model: model,
      prompt: prompt,
      stream: false,
      options: {
        temperature: 0.1,
        top_p: 0.9,
        top_k: 40,
        num_predict: 2000
      }
    });

    if (response.data.error) {
      throw new Error(response.data.error);
    }

    return response.data.response;
  } catch (error) {
    debugLog('=== ERREUR REQUÊTE OLLAMA ===');
    if (error instanceof Error) {
      debugLog('Détails de l\'erreur:', error);
    }
    throw error;
  }
}

// Fonction pour sauvegarder le texte traduit
async function saveTranslatedText(text: string, outputPath: string, format: string): Promise<string> {
  const outputDir = dirname(outputPath);
  
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }
  
  if (format === 'txt') {
    await writeFile(outputPath, text, 'utf-8');
    return outputPath;
  } else {
    // Pour l'instant, on sauvegarde en txt même si format est pdf
    await writeFile(outputPath, text, 'utf-8');
    return outputPath;
  }
}

// Route de traduction
app.post('/api/translate', upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    if (!file) {
      throw new Error('Aucun fichier fourni');
    }

    const targetLanguage = req.body.targetLanguage || 'fr';
    const model = req.body.model || 'mistral';
    const translationMode = req.body.translationMode || 'text';
    const ocrModel = req.body.ocrModel;
    const outputFormat = req.body.outputFormat || 'txt';

    debugLog('=== DÉBUT DE LA TRADUCTION ===');
    debugLog('Fichier:', file.path);
    debugLog('Langue cible:', targetLanguage);
    debugLog('Mode de traduction:', translationMode);
    debugLog('Modèle de traduction:', model);
    if (translationMode === 'ocr') {
      debugLog('Modèle OCR:', ocrModel);
    }

    let textToTranslate: TextChunk[];

    // Étape 1: Extraction du texte (avec ou sans OCR)
    if (translationMode === 'ocr') {
      debugLog('=== DÉBUT DE L\'OCR ===');
      if (!ocrModel) {
        throw new Error('Modèle OCR non spécifié');
      }
      textToTranslate = await extractTextFromFile(file.path, true, ocrModel);
      debugLog(`OCR réussi: ${textToTranslate.length} chunks extraits`);
    } else {
      debugLog('=== DÉBUT DE L\'EXTRACTION DE TEXTE ===');
      textToTranslate = await extractTextFromFile(file.path, false, '');
      debugLog(`Extraction réussie: ${textToTranslate.length} chunks extraits`);
    }

    // Étape 2: Traduction du texte
    debugLog('=== DÉBUT DE LA TRADUCTION ===');
    const translatedChunks: string[] = [];
    const totalChunks = textToTranslate.length;
    const startTime = Date.now();

    for (let i = 0; i < totalChunks; i++) {
      const chunk = textToTranslate[i];
      debugLog(`Traduction du chunk ${i + 1}/${totalChunks} (Page ${chunk.pageNumber})`);

      debugLog('=== DÉBUT REQUÊTE OLLAMA ===');
      debugLog('Modèle:', model);
      
      const prompt = `Translate the following text from English to ${targetLanguage}. Maintain the same tone and style. Here's the text:

${chunk.text}

Translation:`;

      const translatedText = await ollamaRequest(model, prompt);
      translatedChunks.push(translatedText);

      const progress = Math.round(((i + 1) / totalChunks) * 100);
      const elapsedTime = Date.now() - startTime;
      const estimatedTotalTime = (elapsedTime / (i + 1)) * totalChunks;
      const estimatedTimeRemaining = estimatedTotalTime - elapsedTime;

      eventEmitter.emit('translationProgress', {
        progress,
        status: 'translating',
        currentChunk: i + 1,
        totalChunks,
        estimatedTimeRemaining
      });

      debugLog(`Chunk ${i + 1} traduit (${progress}% complété)`);
    }

    // Combiner tous les chunks traduits
    const translatedText = translatedChunks.join('\n\n');

    // Générer le nom du fichier de sortie
    const outputFileName = file.originalname
      .replace(/\.[^/.]+$/, '')
      .replace(/[^a-zA-Z0-9-_]/g, '_')
      + `_${targetLanguage}.${outputFormat}`;

    // Créer un dossier 'translations' s'il n'existe pas
    const translationsDir = join(UPLOAD_DIR, 'translations');
    if (!existsSync(translationsDir)) {
      await mkdir(translationsDir, { recursive: true });
    }

    const outputPath = join(translationsDir, outputFileName);

    // Sauvegarder le résultat
    const savedFilePath = await saveTranslatedText(translatedText, outputPath, outputFormat);

    debugLog('=== TRADUCTION TERMINÉE ===');
    debugLog('Fichier de sortie:', savedFilePath);

    // Envoyer le fichier
    res.download(savedFilePath, outputFileName, async (err) => {
      if (err) {
        debugLog('Erreur lors de l\'envoi du fichier:', err);
      }
      // Ne nettoyer que le fichier source
      await unlink(file.path).catch(e => debugLog('Erreur nettoyage:', e));
    });

  } catch (error) {
    debugLog('=== ERREUR DE TRADUCTION ===');
    if (error instanceof Error) {
      debugLog('Détails:', error);
      res.status(500).json({
        success: false,
        error: 'Erreur lors de la traduction',
        details: error.message
      });
    } else {
      res.status(500).json({
        success: false,
        error: 'Erreur inconnue lors de la traduction'
      });
    }
  }
});

// Route pour récupérer la liste des modèles
app.get('/api/models', async (req, res) => {
  console.log('=== Requête GET /api/models ===');
  console.log('Headers:', req.headers);
  
  try {
    console.log('Tentative de connexion à Ollama...');
    const response = await axios.get<OllamaResponse>('http://localhost:11434/api/tags');
    console.log('Réponse Ollama status:', response.status);
    
    // Validation de la réponse Ollama
    if (!response.data || !Array.isArray(response.data.models)) {
      console.error('Réponse Ollama invalide:', response.data);
      throw new Error('Format de réponse Ollama invalide');
    }
    
    // Transformation des modèles
    const models = response.data.models
      .filter((model: OllamaModel) => {
        // Vérifier que le modèle a toutes les propriétés requises
        return model && 
               model.name && 
               model.details && 
               model.details.parameter_size &&
               model.details.families;
      })
      .map((model: OllamaModel) => {
        // Déterminer si c'est un modèle multimodal (capable d'OCR)
        const isMultimodal = model.details.families.includes('clip');
        const capabilities = ['translation'];
        if (isMultimodal) {
          capabilities.push('ocr');
        }
        
        return {
          name: model.name,
          description: `${model.name} (${model.details.parameter_size})`,
          capabilities,
          details: {
            parameterSize: model.details.parameter_size,
            families: model.details.families,
            quantization: model.details.quantization_level
          }
        };
      });
    
    console.log('Modèles filtrés et transformés:', JSON.stringify(models, null, 2));
    
    // Envoi de la réponse
    res.json({ 
      models,
      count: models.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erreur détaillée:', error);
    res.status(500).json({ 
      error: 'Impossible de récupérer la liste des modèles',
      details: error instanceof Error ? error.message : 'Erreur inconnue',
      timestamp: new Date().toISOString()
    });
  }
});

// Démarrage du serveur
app.listen(port, () => {
  console.log(`Serveur démarré sur le port ${port}`);
}).on('error', (error: Error) => {
  console.error('Erreur lors du démarrage du serveur:', error);
  process.exit(1);
});
